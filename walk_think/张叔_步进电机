170618：
需求：
	用旋转编码器调节档次，在每个档次步进电机转的转不同的步数来带动纸移动，
	一共设6档，旋转编码器调档，一个七段数码管显示档数，旋转编码开关按键触发电机转动，


电路：蓝牙模块、旋转编码开关、调试串口（USART1）接好了，
	  步进电机虽然接了，但是旋转编码开关使用了TIM3，电机两个IO口接到PB0,PB1,也是TIM3的，无法同时使用，


软件：
1、旋转编码开关驱动使用之前跳的（非常感谢有清给的代码），还有问题，转多几下，会出现错误，
	问题：
		1、为什么会出错？
		2、定时器驱动编码器的原理？


2、存储每档转的步数及圈数
	1、把STM32内部flash用作EPPROM
	2、每档存储格式：一共3字节：
		第一个字节存圈数，第二跟第三存步数
		6档：一共要3X6=18个字节保存有效数据，
		存储方式：AA+长度+有效数据+校验+AA 一共22字节
	3、因为这数据不用频繁改动，所以不用考虑flash寿命的问题，只要固定一些来保存，



	问题：
		STM32内部flash当作EEPROM使用如何操作，如何读（按页？按字节？），如何写（按页？按字节？），擦除方式？
		写：word | halfword 页擦除
	使用：
		操作流程：
		读：解锁->擦除(扇区擦除）->写->锁保护
		写的方式有：word | halfword,不同型号的芯片有不同的写入方式，有且只有一种（只支持一种写法）
		一开始从网上找的代码是word写入，一直调都调不出来，只要一些就触发HardFault_Handler，然后改为halfword就可以通过了，

		读：解锁->读（word | halfword)->锁保护
		在调读的时候又出现了HardFault_Handler，同样也是字节数的问题，网上找的代码也是word方式读，又被这个问题搞了很久，为什么就不会想到这跟写的时候碰到的问题一样呢？

		由于STM32 flash 读跟写都是word | halfword,如果要转成字节的话，就涉及到大端小端的问题，

	问题：
	在调读写flash过程中，出现过很多次HardFault_Handler，HardFault_Handler是什么？可以怎么处理？
		M3内核说明中有关异常处理，
		网上找到的一个处理方式：
			void HardFault_Handler(void)  
			{  
			  uint32_t r_sp ;  
			  
			  r_sp = __get_PSP(); //获取SP的值  
			  PERROR(ERROR,Memory Access Error!);  
			  Panic(r_sp);  
			   
			  while (1);  
			}  

	2017/08/12：
		又碰到了进入HardFault_Handler的问题，情况是：开机的时候，读Flash操作就会产生HardFault_Handler异常，经过调试发现，是读Flash函数中有个指针声明的时候没有初始化，导致在用这个指针的时候产生HardFault_Handler异常，
		原来的程序如下：
			void Read_Flash(u8 *buff, u8 len)
			{
			    u8 k=0;
			    u32 Address;
			    u16 *temp;
				u8 *te;
					FLASH_UnlockBank1();
			    Address = WriteFlashAddress;

			    for(k=0;k<len;k+=2)
			    {
			        *temp =  (*(vu16*) Address);
							te = (u8 *)temp;
							if(k+2<=len)
							{
								buff[k+1] = *te;
								te++;
								buff[k]   = *te;
							}else
							{
								buff[k] = *te;
							}
							Address += 2;
			    }
				FLASH_Lock();
			}
		修改后的程序如下：
			void Read_Flash(u8 *buff, u8 len)
			{
			    u8 k=0;
			    u32 Address;
			    u16 *temp=NULL;
				  u8 *te=NULL;
					FLASH_UnlockBank1();
			    Address = WriteFlashAddress;

			    for(k=0;k<len;k+=2)
			    {
			        *temp =  (*(vu16*) Address);
							te = (u8 *)temp;
							if(k+2<=len)
							{
								buff[k+1] = *te;
								te++;
								buff[k]   = *te;
							}else
							{
								buff[k] = *te;
							}
							Address += 2;
			    }
				FLASH_Lock();
			}


		修改的地方为：
			    u16 *temp;
				u8 *te;
		修改后：
			    u16 *temp=NULL;
				  u8 *te=NULL;

	    这是什么原因？
	    	猜想：
	    	可能是指针定义时未初始化，有个随机值（某个地址），当对这个指针操作时，如果是不允许读写的地址，就会引起异常，
	    
3、PWM，驱动电机
timer设置为单次PWM输出，然后控制固定个PWM输出来控制电机转动，
问题：
	1、如何实现，

4、整体逻辑：



5、突然想到，为什么还要弄个蓝牙跟APP，通过手机来调试&设置每个档次的步数呢，这样物料成本就高了，也还要花时间写个APP；
	解决方案还有一个：
		有两个工作模式：
			1、调试模式，可用于调试（测出每个档次的步数圈数），并保存，
			2、工作模式，仅仅用于驱动步进电机，
不过，这个算法就复杂了点，

实现：
用个跳线帽，选择不同的工作方式，
1、调试模式：
模式：
数码管小数点只是工作状态：
常亮表示：档数选择，转动编码快关，调节档数，
闪烁表示：在调节step,转动编码快关，电机转动，并记录转动step,
通过编码开关按键选择选择档数，还是调节档数，


初始化：
档数，数码管，小数点，步进电机圈数&步数，
开机：档数选择，数码管显示1（要调节的档数）,小数点常亮,转动编码开关，调节档数，
选定档数，按编码开关，进行调节step,调节完，再次按编码开关，保存所调节档数，并进入档数选择模式，

2、工作模式：
工作：旋转编码开关选择gears,按键触发电机转动，
初始化：
1、读取数据，
2、初始化变量，


6、数码管接法：
A11: H
A12: G
A15: F
B3:  D
B4:  E
B5: C
B6: B
B7: A




2017/08/11：
1、调试模式时，调试步进电机转的步数：
	转动编码开关时，增加计数，
	转动步进电机，减小计数，
	怎么同步?

STM32中断：
1、STM32(Cortex-M3)中有两个优先级的概念——抢占式优先级和响应优先级
	先占优先级的概念等同于51单片机中的中断。假设有两中断先后触发，已经在执行的中断先占优先级如果没有后触发的中断 先占优先级更高，就会先处理先占优先级高的中断。也就是说又有较高的先占优先级的中断可以打断先占优先级较低的中断。这是实现中断嵌套的基础。
    次占优先级只在同一先占优先级的中断同时触发时起作用，先占优先级相同，则优先执行次占优先级较高的中断。次占优先级不会造成中断嵌套。 如果中断的两个优先级都一致，则优先执行位于中断向量表中位置较高的中断。




2017/08/16：
1、今天调试时，Flash读写又出现问题，不确定是读的问题，还是写的问题，反正是读出来的数据跟写的数据不一致，那该怎么办？有什么解决方案？
	1、调试方法，
		在调试过程中，突然想到，竟然不知道是写还是读的问题，那我就先把Flash中的数据确定，通过Jlink把flash中的数据确定问一定的数据，然后再用自己写的程序读出来，

		或者写完数据后，通过Jlink读出Flash中的数据，就可以确定数据有没有正确的写入，

		进过调试发现是读的时候出的问题，
		原来的程序是这样：
		void Read_Flash(u8 *buff, u8 len)
		{
		    u8 k=0;
		    u32 Address;
		    u16 *temp=NULL;
			  u8 *te=NULL;
				FLASH_Unlock();
		    Address = WriteFlashAddress;
		    for(k=0;k<len;k+=2)
		    {
		        temp =(*(vu16*) Address);
						te = (u8 *)&temp;
						if(k+2<=len)
						{
							buff[k+1] = *te;
							te++;
							buff[k]   = *te;
						}else
						{
							buff[k] = *te;
						}
						Address += 2;
		    }
			FLASH_Lock();
		}
		更改后的程序是这样的：
		void Read_Flash(u8 *buff, u8 len)
		{
		    u8 k=0;
		    u32 Address;
		    u16 temp;
			  u8 *te=NULL;
				FLASH_Unlock();
		    Address = WriteFlashAddress;
		    for(k=0;k<len;k+=2)
		    {
		        temp =*(__IO uint16_t *)Address;// (*(vu32*) Address);// (*(vu16*) Address);
						te = (u8 *)&temp;
						if(k+2<=len)
						{
							buff[k+1] = *te;
							te++;
							buff[k]   = *te;
						}else
						{
							buff[k] = *te;
						}
						Address += 2;
		    }
				printf("\r\n");
			FLASH_Lock();
		}



2017/08/18：
经过测试大概25步转90度，100步360度，也就是一步3.6度