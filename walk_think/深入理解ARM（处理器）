买了半ARM Cortex-M3与Cortex-M4权威指南，
出发点是什么？
目标是什么？
要达到什么？

学了这本书，我有什么样的收获？

有什么方法学？用什么学习方法（方式）？

状态：
1、调试状态
2、Thumb状态
操作模式：
1、处理模式
2、线程模式
寄存器：

1、通用寄存器：R0-R12
	R0——R7：低寄存器，R8-R12高寄存器
	许多16位指令只能访问低寄存器，

2、栈指针（SP）：R13   可通过PUSH指令和POP操作实现栈存储的访问
	两个栈指针：主栈指针（MSP  SP_main）、进程栈指针（PSP，SP_process）

3、链接寄存器（LR）：R14  用于函数或子程序调用时返回地址的保存

4、程序计数器（PC）：R15


特殊寄存器：特殊寄存器未经过存储器映射，可以使用MSR和MRS等特殊寄存器访问指令来进行访问（没有与之相关联的访问地址）

1、程序状态寄存器：xPSR
	应用PSR（APSR）：
		整数运算的状态标识（N-Z-C-V位)：（ALU标志——>算术逻辑单元（英语：Arithmetic Logic Unit, ALU））
			N：为1时，结果为负值，为0时，结果为正值，
			Z：指令执行结果为0，置0，
			C: 结果的进位标志，
			V：结果溢出
		Q状态标志
		GE位
	执行PSR（EPSR） （无法直接用MSR，MRS访问）
	中断PSR（IPSR）（只读）
	这三个寄存器可以组合访问：
	MRS r0,PSR ;读组合状态寄存器
	MSR r0,PSR ;写组合状态寄存器
	也可单独访问：
	MRS r0, APSR ;将标志状态读入R0
	MSR APSR ,r0 ;写标志状态


2、PRIMASK、FAULTMASK、BASEPRI寄存器（用于异常或中断屏蔽，只有在特权访问等级才可以操作）

PRIMASK：置 1 后，就关掉所有可屏蔽的异常，只剩下 NMI 和硬 fault 可以响应
	最常见用途：在时间要求很严格的进程中禁止所有中断
FAULTMASK：当它置 1 时，只有 NMI 才能响应，所有其它的异常，甚至是硬 fault，也通通屏蔽

BASEPRI：定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关

3、CONTROL寄存器
控制寄存器有两个用途，其一用于定义特权级别，其二用于选择当前使用哪个堆栈指针（栈指针选择）


向量表：
向量表是什么？：存储中断服务程序地址？



2107/07/13：
AMBA（高级微控制器总线构架）：通用总线接口，
M3、M4主要使用AHB Lite协议：SRAM、外设总线桥（APB）、高速外设
I-CODE、D-CODE：Flash存储器
私有外设总线：PPB


指令集：
突然意识到，处理器的指令集就对应处理器的功能，比如算术操作对应算术单元，移位指令对应移位单元（移位寄存器），处理器有什么样功能的指令集就对应相应的单元


位段操作：




2017/07/16：
AREA：该指令指示汇编程序汇编新的代码节或数据节
SPACE：申请一片内存空间。但不赋初值


PS：
1、arm编译好像是遵循的ELF文件格式

C程序中的内存：
 BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。   


 数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
     
 代码段：
 代码段（code segment/ textsegment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 
 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）    

 栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。



 2017/07/17：
 Bootloader & APP:
 1、bootloader Flash使用的范围，中断向量
    APP flash 使用起始地址，中断向量重定向


问题：
1、APP下载完并写入Flash后，有没有进行校验？


2017/07/18：
在老的台式机上安装了arm-none-eabi-gcc，并且跑了下Cortex-M3权威指南中的例子，也就用用as、ld等命令，
汇编：arm-none-eabi-as -mcpu=cortex-m3 -mthumb example1.s -o example1.o
链接：arm-none-eabi-ld -Ttext 0x0 -o example1.out example1.o
使用目标拷贝命令（objcopy）来产生二进制文件：arm-none-eabi-objcopy -Obinary example1.out example1.bin
反汇编：arm-none-eabi-objdump -S example1.out > example1.list



汇编代码，看是能够看懂，但肯定是不会写，

2017/07/19：
今天目标是ELF & C 运行环境（ARM启动时初始化的目标）：


ELF：
ELF适用于3种文件结构
1、重定向文件
	也就是经常见到的.o文件，用于保存代码和数据，链接器用使用这个文件来创建可执行文件或者共享文件
2、可执行文件
	也就是linux下面的.out文件，用于执行
3、共享文件
	常见的静态库.lib或者动态库.so，就是这个文件格式，就是由多个.o压缩成的，可以用于保存代码或者数据，节省编译时间

上面三种文件，再综合一下，可以分为两种
1、链接文件（中间态）
2、可执行文件（最终态）



数据的分布，函数的调用和内存分布，以及怎么将这些元素变成BIN文件
哈弗结构：数据和代码分离（代码中，程序中）
bin包含了数据部分和代码部分，某些情况下， bin也会包含有一些调试信息和备注信息

C语言变量类型：全局变量，局部变量，初始化、未初始化变量，文件作用域变量／函数，然后涉及到这些变量的存储方式，

局部变量分配在栈里面，属于动态分配机制
未初始化的变量放置于.bss段中，初始化的变量放置于.data段中，某些情况下，我们需要使用大量的常量数据（比如图片数据，字库），可以将这些放置于.text段中


ELF文件是什么（或者干嘛用）？
1、管理基本数据段（局部变量、全局变量。。。）

2、实现调试功能

3、

数据、代码、调试、


涉及到的命令：
1、objdump：用来反汇编

2、readelf：用来读取elf文件里面的section, header等信息

3、xxd ：查看原始HEX信息
如：xxd a.out 


ELF文件结构：
1、最前部是ELF文件头，描述整个文件的基本属性：
	1、ELF文件类型
	2、版本
	3、目标机器类型
	4、程序入口地址
	。。。。。。。
2、ELF文件的各个段：段表->描述ELF文件的所有段的信息，如：段名、段的长度、在文件中的偏移、读写权限。。。。。。。
段的类型：
	1、PROGBITS：程序内容，包括代码、数据、调试信息
	2、NOBITS：类似PROGBITS，但在文件本身中不分配空间，用于在程序加载时分配空间的BSS数据，
	3、SYMTAB：包含所有的符号并用于普通的连接器
	4、DYNSY：包含用于动态链接的符号
	5、STRTAB：字符串表，ELF经常为不同的用途包含不同的字符串表，比如段名、普通符号名称、动态链接名称。。。
	6、REL：重定位信息，REL将重定位值加到存储在代码或数据中的基地址上，
	7、RELA：重定位信息，在自身中已保存了重定位需要的基地址值
	8、DYNAMIC：动态链接信息
	9、HASH：运行时符号哈希表

段表定义里用到三个标志位：
1、ALLOC：表示当程序加载时段要占据内存
2、WRITE：意思是该段加载后是可写的，
3、EXECINSTR：意思是该段包含可执行的机器码

典型的可重定位可执行文件的段有：
1、.text：具有ALLOC和EXECINSTR属性的PROGBITS类型的段，已编译程序的机器代码
2、.data：具有ALLOC和WRITE属性的PROGBITS类型段，已初始化的全局C变量，
3、.rodata：具有ALLOC属性的PROGBITS类型的段，只读属性，比如printf语句中的字符串和开关语句的跳转表
4、.bss
5、.rel.text、.rel.data、.rel.rodata：
6、init、.fini：
7、.symtab、.dynsym
8、.strtab、.dynstr：
9、.got：
10、.plt：
11、.debug：
12、.line：
13、.comment：


2017/07/20：
链接脚本：



2017/07/22：
C是如何编译到汇编？（Cortex-M3权威指南->Cortex-M3 的低层编程)


摘录：
1、
当使用 C 开发程序时，推荐开启 CM3 的双字对齐管理机制（在 NVIC 配置与控制寄存器中，把STKALIGN 置位），代码形如：
	#define NVIC_CCR ((volatile unsigned long *)(0xE000ED14))
	*NVIC_CCR ＝ *NVIC_CCR | 0x200; //设置STKALIGN位
这是用于确保系统能严格遵守 APCS 过程调用标准





汇编：


PROC
一般格式为：                   <过程名>                   PROC        [类型]
此指令为过程定义指令。过程即子程序，一个过程可以被其他程序调用（CALL指令）。
<过程名>           PROC  [类型]
                   …….
                   …….
 
    ENDP
注：PROC和ENDP必须成对出现。



IMPORT ，定义表示这是一个外部变量的标号，不是在本程序定义的

EXPORT ，表示本程序里面用到的变量提供给其他模块调用的。


2017/
APCS：ARM 过程调用标准(ARM Procedure Call Standard)

http://www.cnblogs.com/hongzg1982/articles/2314457.html

APCS 定义了:
	对寄存器使用的限制。
	使用栈的惯例。
	在函数调用之间传递/返回参数。
	可以被‘回溯’的基于栈的结构的格式，用来提供从失败点到程序入口的函数(和给予的参数)的列表。



M0 指令集：
1、处理器内移动数据（寄存器）
MOV：
MOVS：
MRS：
2、存储器访问
LDR     LDR     STR
LDRH    LDRSH   STRH
LDRB    LDRSB   STRB
3、栈空间操作
PUSH
POP
4、算符运算
ADDS
ADD
ADR
ADC
ADCS

SUB
SUBS
SBCS
SBC

RSBS
NEG
MULS
MULS

CMP
CMN

5、逻辑运算
ANDS
AND

ORRS
ORR

EORS
EOR

BICS
BIC


MVNS
MVN

TST


6、移位和循环
ASRS
ASR

LSLS
LSL

LSRS
LSR


RORS
ROR

7、展开和顺序反转
字节顺序反转：
REV

半字内字节顺序反转
REV16

REVSH

SXTB
SXTH
UXTB


8、流程控制
无条件跳转：
B
有条件跳转：
B<cond>

<cond>：
EQ
NE
CS/HS
CC/LO
MI
PL
VS
VC
HI
LS
GE
LT
GT
LE
如：BEQ

BL:跳转并链接

BX：跳转并交换

BLX：跳转链接并交换

9：存储器屏障指令：
DMB

DSB

ISB


10、异常相关指令
SVC

CPSIE：使能中断
CPSID：禁止中断

11、休眠
WFI
WFE
SEV

12：其他指令：
NOP

BKPT

YIELD

13：伪指令
LDR