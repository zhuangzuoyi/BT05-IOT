买了半ARM Cortex-M3与Cortex-M4权威指南，
出发点是什么？
目标是什么？
要达到什么？

学了这本书，我有什么样的收获？

有什么方法学？用什么学习方法（方式）？

状态：
1、调试状态
2、Thumb状态
操作模式：
1、处理模式
2、线程模式
寄存器：

1、通用寄存器：R0-R12
	R0——R7：低寄存器，R8-R12高寄存器
	许多16位指令只能访问低寄存器，

2、栈指针（SP）：R13   可通过PUSH指令和POP操作实现栈存储的访问
	两个栈指针：主栈指针（MSP  SP_main）、进程栈指针（PSP，SP_process）

3、链接寄存器（LR）：R14  用于函数或子程序调用时返回地址的保存

4、程序计数器（PC）：R15


特殊寄存器：特殊寄存器未经过存储器映射，可以使用MSR和MRS等特殊寄存器访问指令来进行访问（没有与之相关联的访问地址）

1、程序状态寄存器：xPSR
	应用PSR（APSR）：
		整数运算的状态标识（N-Z-C-V位)：（ALU标志——>算术逻辑单元（英语：Arithmetic Logic Unit, ALU））
			N：为1时，结果为负值，为0时，结果为正值，
			Z：指令执行结果为0，置0，
			C: 结果的进位标志，
			V：结果溢出
		Q状态标志
		GE位
	执行PSR（EPSR） （无法直接用MSR，MRS访问）
	中断PSR（IPSR）（只读）
	这三个寄存器可以组合访问：
	MRS r0,PSR ;读组合状态寄存器
	MSR r0,PSR ;写组合状态寄存器
	也可单独访问：
	MRS r0, APSR ;将标志状态读入R0
	MSR APSR ,r0 ;写标志状态


2、PRIMASK、FAULTMASK、BASEPRI寄存器（用于异常或中断屏蔽，只有在特权访问等级才可以操作）

PRIMASK：置 1 后，就关掉所有可屏蔽的异常，只剩下 NMI 和硬 fault 可以响应
	最常见用途：在时间要求很严格的进程中禁止所有中断
FAULTMASK：当它置 1 时，只有 NMI 才能响应，所有其它的异常，甚至是硬 fault，也通通屏蔽

BASEPRI：定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关

3、CONTROL寄存器
控制寄存器有两个用途，其一用于定义特权级别，其二用于选择当前使用哪个堆栈指针（栈指针选择）


向量表：
向量表是什么？：存储中断服务程序地址？



2107/07/13：
AMBA（高级微控制器总线构架）：通用总线接口，
M3、M4主要使用AHB Lite协议：SRAM、外设总线桥（APB）、高速外设
I-CODE、D-CODE：Flash存储器
私有外设总线：PPB


指令集：
突然意识到，处理器的指令集就对应处理器的功能，比如算术操作对应算术单元，移位指令对应移位单元（移位寄存器），处理器有什么样功能的指令集就对应相应的单元


位段操作：




2017/07/16：
AREA：该指令指示汇编程序汇编新的代码节或数据节
SPACE：申请一片内存空间。但不赋初值


PS：
1、arm编译好像是遵循的ELF文件格式

C程序中的内存：
 BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。   


 数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
     
 代码段：
 代码段（code segment/ textsegment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 
 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）    

 栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。



 2017/07/17：
 Bootloader & APP:
 1、bootloader Flash使用的范围，中断向量
    APP flash 使用起始地址，中断向量重定向


问题：
1、APP下载完并写入Flash后，有没有进行校验？


2017/07/18：
在老的台式机上安装了arm-none-eabi-gcc，并且跑了下Cortex-M3权威指南中的例子，也就用用as、ld等命令，
汇编：arm-none-eabi-as -mcpu=cortex-m3 -mthumb example1.s -o example1.o
链接：arm-none-eabi-ld -Ttext 0x0 -o example1.out example1.o
使用目标拷贝命令（objcopy）来产生二进制文件：arm-none-eabi-objcopy -Obinary example1.out example1.bin
反汇编：arm-none-eabi-objdump -S example1.out > example1.list



汇编代码，看是能够看懂，但肯定是不会写，